
axiomatic Padding {

  logic type padding
  
}

tag voidP = {
}

type voidP = [voidP]

tag charP = voidP with {
  int8 charM: 8;
}

tag unsigned_charP = {
  uint8 unsigned_charM: 8;
}

type unsigned_charP = [unsigned_charP]

tag intP = {
  int32 intM: 32;
}

type intP = [intP]

predicate _Unchanged{K, L}(intP[..] a, integer first, integer last) =
(\forall integer i_1;
  (((first <= i_1) && (i_1 < last)) ==>
    (\at((a + i_1).intM,K) == \at((a + i_1).intM,L))))

predicate _Unchanged_0{K, L}(intP[..] a_0, integer n_1) =
_Unchanged{K, L}(a_0, 0, n_1)

lemma UnchangedStep{K, L} :
(_C_1 : (\forall intP[..] a_1;
          (\forall integer n_2;
            ((0 <= n_2) ==>
              (_Unchanged_0{K,
                L}(a_1, n_2) ==>
                ((\at((a_1 + n_2).intM,K) == \at((a_1 + n_2).intM,L)) ==>
                  _Unchanged_0{K,
                  L}(a_1, (n_2 + 1))))))))

lemma UnchangedSection{K, L} :
(_C_2 : (\forall intP[..] a_2;
          (\forall integer m;
            (\forall integer n_3;
              (((0 <= m) && (m <= n_3)) ==>
                (_Unchanged_0{K, L}(a_2, n_3) ==> _Unchanged_0{K, L}(a_2, m)))))))

predicate _Swap{L1, L2}(intP[..] a_3, integer i_2, integer j_0, integer size) =
(((\at((a_3 + i_2).intM,L1) == \at((a_3 + j_0).intM,L2)) &&
   (\at((a_3 + j_0).intM,L1) == \at((a_3 + i_2).intM,L2))) &&
  (\forall integer k_1;
    (((((0 <= k_1) && (k_1 < size)) && (k_1 != i_2)) && (k_1 != j_0)) ==>
      (\at((a_3 + k_1).intM,L1) == \at((a_3 + k_1).intM,L2)))))

predicate _CheckTask{L1, L2}(intP[..] a_4, intP[..] b, integer size_a) =
(\forall integer i_3;
  ((((0 <= i_3) && (i_3 < size_a)) && ((i_3 % 2) == 0)) ==>
    ((\at((b + ((a_4 + i_3).intM :> integer)).intM,L1) ==
       \at((b + ((a_4 + (i_3 + 1)).intM :> integer)).intM,L2)) &&
      (\at((b + ((a_4 + (i_3 + 1)).intM :> integer)).intM,L1) ==
        \at((b + ((a_4 + i_3).intM :> integer)).intM,L2)))))

axiomatic MaxInd {

  logic integer max_ind{L}(intP[..] a_5, uint32 n_4)
   
  axiom a1{L} :
  (_C_3 : (\forall intP[..] a_6;
            (\forall uint32 n_5;
              ((0 <= max_ind{L}(a_6, n_5)) &&
                (max_ind{L}(a_6, n_5) <= (n_5 :> integer))))))
   
  axiom a2{L} :
  (_C_4 : (\forall intP[..] a_7;
            (\forall uint32 n_6;
              (\forall integer i_4;
                (((0 <= i_4) && (i_4 < (n_6 :> integer))) ==>
                  ((a_7 + i_4).intM <= (a_7 + max_ind{L}(a_7, n_6)).intM))))))
  
}

axiomatic Permut {

  predicate _Permut{L1, L2}(intP[..] t1, intP[..] t2, integer n_7)
   
  axiom Permut_refl{L} :
  (_C_5 : (\forall intP[..] t;
            (\forall integer n_8;
              _Permut{L, L}(t, t, n_8))))
   
  axiom Permut_sym{L1, L2} :
  (_C_6 : (\forall intP[..] t1_0;
            (\forall intP[..] t2_0;
              (\forall integer n_9;
                (_Permut{L1,
                  L2}(t1_0, t2_0, n_9) ==>
                  _Permut{L2,
                  L1}(t2_0, t1_0, n_9))))))
   
  axiom Permut_trans{L1, L2, L3} :
  (_C_7 : (\forall intP[..] t1_1;
            (\forall intP[..] t2_1;
              (\forall intP[..] t3;
                (\forall integer n_10;
                  ((_Permut{L1,
                     L2}(t1_1, t2_1, n_10) &&
                     _Permut{L2,
                     L3}(t2_1, t3, n_10)) ==>
                    _Permut{L1,
                    L3}(t1_1, t3, n_10)))))))
   
  axiom Permut_exchange{L1, L2} :
  (_C_8 : (\forall intP[..] t1_2;
            (\forall intP[..] t2_2;
              (\forall integer i_5;
                (\forall integer j_1;
                  (\forall integer n_11;
                    ((((\at((t1_2 + i_5).intM,L1) ==
                         \at((t2_2 + j_1).intM,L2)) &&
                        (\at((t1_2 + j_1).intM,L1) ==
                          \at((t2_2 + i_5).intM,L2))) &&
                       (\forall integer k_2;
                         (((((0 <= k_2) && (k_2 < n_11)) && (k_2 != i_5)) &&
                            (k_2 != j_1)) ==>
                           (\at((t1_2 + k_2).intM,L1) ==
                             \at((t2_2 + k_2).intM,L2))))) ==>
                      _Permut{L1,
                      L2}(t1_2, t2_2, n_11))))))))
   
  lemma SwapImmutability{L1, L2} :
  (_C_9 : (\forall intP[..] a_8;
            (\forall int32 n_12;
              (\forall int32 i_6;
                (\forall int32 j_2;
                  (((((((0 :> int32) <= i_6) && (i_6 < n_12)) &&
                       ((0 :> int32) <= j_2)) &&
                      (j_2 < n_12)) &&
                     _Swap{L1,
                     L2}(a_8, (i_6 :> integer), (j_2 :> integer),
                         (n_12 :> integer))) ==>
                    _Permut{L1,
                    L2}(a_8, a_8, (n_12 :> integer))))))))
   
  lemma Validity{L1} :
  (_C_10 : (\forall intP[..] a_9;
             (\forall int32 n_13;
               (((n_13 > (0 :> int32)) &&
                  (\forall integer k_3;
                    (((0 <= k_3) && (k_3 < (n_13 :> integer))) ==>
                      \at(\at((((\offset_min(\at(a_9,L1)) <= \at(k_3,L1)) &&
                                 (\offset_max(\at(a_9,L1)) >= \at(k_3,L1))) &&
                                (\forall integer __framac_tmp1;
                                  (((\at(k_3,L1) <= __framac_tmp1) &&
                                     (__framac_tmp1 <= \at(k_3,L1))) ==>
                                    true))),L1),L1)))) ==>
                 _Permut{L1,
                 L1}(a_9, a_9, (n_13 :> integer))))))
  
}

int32 size_b;

unit task(intP[..] a, intP[..] b, uint32 size_a)
  requires ((_C_52 : (((size_a :> integer) % 2) == 0)) &&
             ((_C_53 : \at((if (\at(0,Here) <=
                                 \at(((size_a :> integer) - 1),Here)) then 
                           (((\offset_min(\at(a,Here)) <= \at(0,Here)) &&
                              (\offset_max(\at(a,Here)) >=
                                \at(((size_a :> integer) - 1),Here))) &&
                             (\forall integer __framac_tmp2;
                               (((\at(0,Here) <= __framac_tmp2) &&
                                  (__framac_tmp2 <=
                                    \at(((size_a :> integer) - 1),Here))) ==>
                                 true))) else true),Here)) &&
               ((_C_54 : \at((if (\at(0,Here) <=
                                   \at(max_ind{Here}(a, size_a),Here)) then 
                             (((\offset_min(\at(b,Here)) <= \at(0,Here)) &&
                                (\offset_max(\at(b,Here)) >=
                                  \at(max_ind{Here}(a, size_a),Here))) &&
                               (\forall integer __framac_tmp3;
                                 (((\at(0,Here) <= __framac_tmp3) &&
                                    (__framac_tmp3 <=
                                      \at(max_ind{Here}(a, size_a),Here))) ==>
                                   true))) else true),Here)) &&
                 ((_C_55 : (\forall integer k_4;
                             (((0 <= k_4) && (k_4 < (size_a :> integer))) ==>
                               ((a + k_4).intM < size_b)))) &&
                   ((_C_56 : (\forall integer k_5;
                               (((0 <= k_5) && (k_5 < (size_a :> integer))) ==>
                                 ((a + k_5).intM >= (0 :> int32))))) &&
                     (_C_57 : (\exists integer mx;
                                ((((0 <= mx) && (mx < (size_a :> integer))) &&
                                   (\forall integer k_6;
                                     (((0 <= k_6) &&
                                        (k_6 < (size_a :> integer))) ==>
                                       ((a + k_6).intM <= (a + mx).intM)))) &&
                                  \at((if (\at(0,Here) <=
                                            \at((a + mx).intM,Here)) then 
                                      (((\offset_min(\at(b,Here)) <=
                                          \at(0,Here)) &&
                                         (\offset_max(\at(b,Here)) >=
                                           \at((a + mx).intM,Here))) &&
                                        (\forall integer __framac_tmp4;
                                          (((\at(0,Here) <= __framac_tmp4) &&
                                             (__framac_tmp4 <=
                                               \at((a + mx).intM,Here))) ==>
                                            true))) else true),Here)))))))));
behavior default:
  ensures (_C_47 : ((_C_48 : _Permut{Old,
                    Here}(\at(b,Old), \at(b,Old), (size_b :> integer))) &&
                     ((_C_50 : _Unchanged_0{Old,
                      Here}(\at(a,Old), (\at(size_a,Old) :> integer))) &&
                       (_C_51 : _CheckTask{Old,
                       Here}(\at(a,Old), \at(b,Old),
                             (\at(size_a,Old) :> integer))))));
{  
   (var uint32 i);
   
   (var int32 tmp);
   
   {  (_C_11 : (i = (0 :> uint32)));
      
      loop 
      behavior default:
        invariant (_C_16 : ((_C_17 : (0 <= (i :> integer))) &&
                             (_C_18 : (i <= size_a))));
      behavior default:
        invariant (_C_15 : (((i :> integer) % 2) == 0));
      behavior default:
        invariant (_C_14 : _CheckTask{Pre, Here}(a, b, ((i :> integer) - 1)));
      behavior default:
        invariant (_C_13 : _Permut{Pre, Here}(b, b, (size_b :> integer)));
      variant (_C_12 : ((size_a :> integer) - (i :> integer)));
      while (true)
      {  
         {  (if (_C_19 : (i < size_a)) then () else 
            (goto while_0_break));
            
            {  (Before : ());
               (_C_24 : (tmp = (_C_23 : (_C_22 : (b +
                                                   (_C_21 : (_C_20 : (a + i)).intM))).intM)));
               (_C_35 : ((_C_34 : (_C_33 : (b +
                                             (_C_32 : (_C_31 : (a + i)).intM))).intM) = 
               (_C_30 : (_C_29 : (b +
                                   (_C_28 : (_C_27 : (a +
                                                       (_C_26 : ((_C_25 : 
                                                                 (i +
                                                                   (1 :> uint32))) :> uint32)))).intM))).intM)));
               (_C_42 : ((_C_41 : (_C_40 : (b +
                                             (_C_39 : (_C_38 : (a +
                                                                 (_C_37 : (
                                                                 (_C_36 : 
                                                                 (i +
                                                                   (1 :> uint32))) :> uint32)))).intM))).intM) = tmp));
               
               {  
                  (assert for default: (_C_43 : (jessie : _Swap{Before,
                                                Here}(b,
                                                      ((a + (i :> integer)).intM :> integer),
                                                      ((a +
                                                         ((i :> integer) + 1)).intM :> integer),
                                                      (size_b :> integer)))));
                  ()
               }
            };
            (_C_46 : (i = (_C_45 : ((_C_44 : (i + (2 :> uint32))) :> uint32))))
         }
      };
      (while_0_break : ());
      
      (return ())
   }
}
