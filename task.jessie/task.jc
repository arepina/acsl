
axiomatic Padding {

  logic type padding
  
}

tag voidP = {
}

type voidP = [voidP]

tag charP = voidP with {
  int8 charM: 8;
}

tag unsigned_charP = {
  uint8 unsigned_charM: 8;
}

type unsigned_charP = [unsigned_charP]

tag intP = {
  int32 intM: 32;
}

type intP = [intP]

predicate _Unchanged{K, L}(intP[..] a, integer first, integer last) =
(\forall integer i_1;
  (((first <= i_1) && (i_1 < last)) ==>
    (\at((a + i_1).intM,K) == \at((a + i_1).intM,L))))

predicate _Unchanged_0{K, L}(intP[..] a_0, integer n_1) =
_Unchanged{K, L}(a_0, 0, n_1)

lemma UnchangedStep{K, L} :
(_C_1 : (\forall intP[..] a_1;
          (\forall integer n_2;
            ((0 <= n_2) ==>
              (_Unchanged_0{K,
                L}(a_1, n_2) ==>
                ((\at((a_1 + n_2).intM,K) == \at((a_1 + n_2).intM,L)) ==>
                  _Unchanged_0{K,
                  L}(a_1, (n_2 + 1))))))))

lemma UnchangedSection{K, L} :
(_C_2 : (\forall intP[..] a_2;
          (\forall integer m;
            (\forall integer n_3;
              (((0 <= m) && (m <= n_3)) ==>
                (_Unchanged_0{K, L}(a_2, n_3) ==> _Unchanged_0{K, L}(a_2, m)))))))

predicate _Swap{L1, L2}(intP[..] a_3, integer i_2, integer j_0, integer size) =
(((\at((a_3 + i_2).intM,L1) == \at((a_3 + j_0).intM,L2)) &&
   (\at((a_3 + j_0).intM,L1) == \at((a_3 + i_2).intM,L2))) &&
  (\forall integer k_1;
    (((((0 <= k_1) && (k_1 < size)) && (k_1 != i_2)) && (k_1 != j_0)) ==>
      (\at((a_3 + k_1).intM,L1) == \at((a_3 + k_1).intM,L2)))))

axiomatic MaxInd {

  logic integer max_ind{L}(intP[..] a_4, uint32 n_4)
   
  axiom a1{L} :
  (_C_3 : (\forall intP[..] a_5;
            (\forall uint32 n_5;
              ((0 <= max_ind{L}(a_5, n_5)) &&
                (max_ind{L}(a_5, n_5) <= (n_5 :> integer))))))
   
  axiom a2{L} :
  (_C_4 : (\forall intP[..] a_6;
            (\forall uint32 n_6;
              (\forall integer i_3;
                (((0 <= i_3) && (i_3 < (n_6 :> integer))) ==>
                  ((a_6 + i_3).intM <= (a_6 + max_ind{L}(a_6, n_6)).intM))))))
  
}

axiomatic Permut {

  predicate permut{L1, L2}(intP[..] t1, intP[..] t2, integer n_7)
   
  axiom permut_refl{L} :
  (_C_5 : (\forall intP[..] t;
            (\forall integer n_8;
              permut{L, L}(t, t, n_8))))
   
  axiom permut_sym{L1, L2} :
  (_C_6 : (\forall intP[..] t1_0;
            (\forall intP[..] t2_0;
              (\forall integer n_9;
                (permut{L1,
                  L2}(t1_0, t2_0, n_9) ==>
                  permut{L2,
                  L1}(t2_0, t1_0, n_9))))))
   
  axiom permut_trans{L1, L2, L3} :
  (_C_7 : (\forall intP[..] t1_1;
            (\forall intP[..] t2_1;
              (\forall intP[..] t3;
                (\forall integer n_10;
                  ((permut{L1,
                     L2}(t1_1, t2_1, n_10) &&
                     permut{L2,
                     L3}(t2_1, t3, n_10)) ==>
                    permut{L1,
                    L3}(t1_1, t3, n_10)))))))
   
  axiom permut_exchange{L1, L2} :
  (_C_8 : (\forall intP[..] t1_2;
            (\forall intP[..] t2_2;
              (\forall integer i_4;
                (\forall integer j_1;
                  (\forall integer n_11;
                    ((((\at((t1_2 + i_4).intM,L1) ==
                         \at((t2_2 + j_1).intM,L2)) &&
                        (\at((t1_2 + j_1).intM,L1) ==
                          \at((t2_2 + i_4).intM,L2))) &&
                       (\forall integer k_2;
                         (((((0 <= k_2) && (k_2 < n_11)) && (k_2 != i_4)) &&
                            (k_2 != j_1)) ==>
                           (\at((t1_2 + k_2).intM,L1) ==
                             \at((t2_2 + k_2).intM,L2))))) ==>
                      permut{L1,
                      L2}(t1_2, t2_2, n_11))))))))
   
  lemma SwapImmutability{L1, L2} :
  (_C_9 : (\forall intP[..] a_7;
            (\forall int32 n_12;
              (\forall int32 i_5;
                (\forall int32 j_2;
                  (((((((0 :> int32) <= i_5) && (i_5 < n_12)) &&
                       ((0 :> int32) <= j_2)) &&
                      (j_2 < n_12)) &&
                     _Swap{L1,
                     L2}(a_7, (i_5 :> integer), (j_2 :> integer),
                         (n_12 :> integer))) ==>
                    permut{L1,
                    L2}(a_7, a_7, (n_12 :> integer))))))))
   
  lemma Validity{L1} :
  (_C_10 : (\forall intP[..] a_8;
             (\forall int32 n_13;
               (((n_13 > (0 :> int32)) &&
                  (\forall integer k_3;
                    (((0 <= k_3) && (k_3 < (n_13 :> integer))) ==>
                      \at(\at((((\offset_min(\at(a_8,L1)) <= \at(k_3,L1)) &&
                                 (\offset_max(\at(a_8,L1)) >= \at(k_3,L1))) &&
                                (\forall integer __framac_tmp1;
                                  (((\at(k_3,L1) <= __framac_tmp1) &&
                                     (__framac_tmp1 <= \at(k_3,L1))) ==>
                                    true))),L1),L1)))) ==>
                 permut{L1,
                 L1}(a_8, a_8, (n_13 :> integer))))))
  
}

int32 size_b;

unit task(intP[..] a, intP[..] b, uint32 size_a)
  requires ((_C_48 : (((size_a :> integer) % 2) == 0)) &&
             ((_C_49 : \at((if (\at(0,Here) <=
                                 \at(((size_a :> integer) - 1),Here)) then 
                           (((\offset_min(\at(a,Here)) <= \at(0,Here)) &&
                              (\offset_max(\at(a,Here)) >=
                                \at(((size_a :> integer) - 1),Here))) &&
                             (\forall integer __framac_tmp2;
                               (((\at(0,Here) <= __framac_tmp2) &&
                                  (__framac_tmp2 <=
                                    \at(((size_a :> integer) - 1),Here))) ==>
                                 true))) else true),Here)) &&
               ((_C_50 : \at((if (\at(0,Here) <=
                                   \at(max_ind{Here}(a, size_a),Here)) then 
                             (((\offset_min(\at(b,Here)) <= \at(0,Here)) &&
                                (\offset_max(\at(b,Here)) >=
                                  \at(max_ind{Here}(a, size_a),Here))) &&
                               (\forall integer __framac_tmp3;
                                 (((\at(0,Here) <= __framac_tmp3) &&
                                    (__framac_tmp3 <=
                                      \at(max_ind{Here}(a, size_a),Here))) ==>
                                   true))) else true),Here)) &&
                 ((_C_51 : (\forall integer k_4;
                             (((0 <= k_4) && (k_4 < (size_a :> integer))) ==>
                               ((a + k_4).intM < size_b)))) &&
                   ((_C_52 : (\forall integer k_5;
                               (((0 <= k_5) && (k_5 < (size_a :> integer))) ==>
                                 ((a + k_5).intM >= (0 :> int32))))) &&
                     (_C_53 : (\exists integer mx;
                                ((((0 <= mx) && (mx < (size_a :> integer))) &&
                                   (\forall integer k_6;
                                     (((0 <= k_6) &&
                                        (k_6 < (size_a :> integer))) ==>
                                       ((a + k_6).intM <= (a + mx).intM)))) &&
                                  \at((if (\at(0,Here) <=
                                            \at((a + mx).intM,Here)) then 
                                      (((\offset_min(\at(b,Here)) <=
                                          \at(0,Here)) &&
                                         (\offset_max(\at(b,Here)) >=
                                           \at((a + mx).intM,Here))) &&
                                        (\forall integer __framac_tmp4;
                                          (((\at(0,Here) <= __framac_tmp4) &&
                                             (__framac_tmp4 <=
                                               \at((a + mx).intM,Here))) ==>
                                            true))) else true),Here)))))))));
behavior default:
  ensures (_C_45 : ((_C_46 : permut{Old,
                    Here}(\at(b,Old), \at(b,Old), (size_b :> integer))) &&
                     (_C_47 : _Unchanged_0{Old,
                     Here}(\at(a,Old), (\at(size_a,Old) :> integer)))));
{  
   (var uint32 i);
   
   (var int32 tmp);
   
   {  (_C_11 : (i = (0 :> uint32)));
      
      loop 
      behavior default:
        invariant (_C_15 : ((_C_16 : (0 <= (i :> integer))) &&
                             (_C_17 : (i <= size_a))));
      behavior default:
        invariant (_C_14 : (((i :> integer) % 2) == 0));
      behavior default:
        invariant (_C_13 : permut{Pre, Here}(b, b, (size_b :> integer)));
      behavior default:
        
        assigns i,
        b;
      variant (_C_12 : ((size_a :> integer) - (i :> integer)));
      while (true)
      {  
         {  (if (_C_18 : (i < size_a)) then () else 
            (goto while_0_break));
            
            {  (_C_23 : (tmp = (_C_22 : (_C_21 : (b +
                                                   (_C_20 : (_C_19 : (a + i)).intM))).intM)));
               (_C_34 : ((_C_33 : (_C_32 : (b +
                                             (_C_31 : (_C_30 : (a + i)).intM))).intM) = 
               (_C_29 : (_C_28 : (b +
                                   (_C_27 : (_C_26 : (a +
                                                       (_C_25 : ((_C_24 : 
                                                                 (i +
                                                                   (1 :> uint32))) :> uint32)))).intM))).intM)));
               (_C_41 : ((_C_40 : (_C_39 : (b +
                                             (_C_38 : (_C_37 : (a +
                                                                 (_C_36 : (
                                                                 (_C_35 : 
                                                                 (i +
                                                                   (1 :> uint32))) :> uint32)))).intM))).intM) = tmp))
            };
            (_C_44 : (i = (_C_43 : ((_C_42 : (i + (2 :> uint32))) :> uint32))))
         }
      };
      (while_0_break : ());
      
      (return ())
   }
}
